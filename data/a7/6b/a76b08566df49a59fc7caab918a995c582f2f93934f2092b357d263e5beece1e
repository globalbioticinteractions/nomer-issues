{"url":"https://api.github.com/repos/globalbioticinteractions/nomer/issues/128","repository_url":"https://api.github.com/repos/globalbioticinteractions/nomer","labels_url":"https://api.github.com/repos/globalbioticinteractions/nomer/issues/128/labels{/name}","comments_url":"https://api.github.com/repos/globalbioticinteractions/nomer/issues/128/comments","events_url":"https://api.github.com/repos/globalbioticinteractions/nomer/issues/128/events","html_url":"https://github.com/globalbioticinteractions/nomer/issues/128","id":1456673826,"node_id":"I_kwDOBvmSqc5W0xQi","number":128,"title":"Parsing Names in a Hierarchical Fashion","user":{"login":"jtmiller28","id":82229873,"node_id":"MDQ6VXNlcjgyMjI5ODcz","avatar_url":"https://avatars.githubusercontent.com/u/82229873?v=4","gravatar_id":"","url":"https://api.github.com/users/jtmiller28","html_url":"https://github.com/jtmiller28","followers_url":"https://api.github.com/users/jtmiller28/followers","following_url":"https://api.github.com/users/jtmiller28/following{/other_user}","gists_url":"https://api.github.com/users/jtmiller28/gists{/gist_id}","starred_url":"https://api.github.com/users/jtmiller28/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jtmiller28/subscriptions","organizations_url":"https://api.github.com/users/jtmiller28/orgs","repos_url":"https://api.github.com/users/jtmiller28/repos","events_url":"https://api.github.com/users/jtmiller28/events{/privacy}","received_events_url":"https://api.github.com/users/jtmiller28/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":801028350,"node_id":"MDU6TGFiZWw4MDEwMjgzNTA=","url":"https://api.github.com/repos/globalbioticinteractions/nomer/labels/enhancement","name":"enhancement","color":"84b6eb","default":true,"description":"New feature or request"}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":3,"created_at":"2022-11-19T21:50:05Z","updated_at":"2024-06-04T13:27:44Z","closed_at":null,"author_association":"NONE","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"So I thought I'd leave the framework for a work in progress idea I have for resolving large datasets with inclusions of complex names here, let me know if there are any complications with my reasoning or thoughts about it as a whole @jhpoelen @seltmann \r\n\r\nFor some background, the underlying issue I have been constantly encountering when resolving names is that the complexity of the name provided by the source doesn't always match the complexity in the catalogue. This shows up in infraspecific epithets, varieties, subsp. etc and has a lot to do with individual decisions in species concepts and what not. I believe this to be a significant issue when trying to create a reusable dataset since it forces the creator of the dataset to pick and choose what level they think would be appropriate for taxonomic specificity, which may not match the catalogues registered names and can thereby result in a loss of resolvedNames by that choice alone.  \r\n\r\nAs an example...for my analysis I endeavor to create a dataset that includes all levels of designations, provided that they are accurate. The underlying problem here is however that alot of names include pieces that are not found in the World of Flora catalogue and result in a lack of resolution since there is no fuzzy matching scheme. The dangers of fuzzy matching when applied to a large set of data are apparent from my past resolutions, therefore I believe this should be avoided unless there is appropriate suspicion for names. \r\n\r\nAn alternative approach suggested by one of my labmate is to construct a for-loop that utilizes the resolver to give the lowest (taxonomic) level of designation possible given the parsed levels of names.\r\n\r\nHere, I'll showcase how when using a parser you can get a name that wont resolve correctly based upon my choice of WFO catalogue.\r\n\r\n`echo -e \"\\tZea mays subsp. mays raza onaveño\" |  nomer append gn-parse`\r\nreturns: Zea mays subsp. mays raza onaveño\tSAME_AS\t\tZea mays ssp. mays raza onaveno\t\r\n\r\nhowever...\r\n`echo -e \"\\tZea mays ssp. mays raza onaveño\" |  nomer append wfo`\r\nZea mays ssp. mays raza onaveño\tNONE\t\tZea mays ssp. mays raza onaveño\t\r\n\r\nwhile\r\n`echo -e \"\\tZea mays subsp. mays\" |  nomer append wfo`\r\nZea mays subsp. mays\tHAS_ACCEPTED_NAME\tWFO:0001096778\tZea mays subsp. mays\t\tsubspecies\t\tAngiosperms | Poales | Poaceae | Zea | Zea mays | Zea mays subsp. mays\tWFO:9949999999 | WFO:9000000415 | WFO:7000000483 | WFO:4000041167 | WFO:0000907754 | WFO:0001096778\tphylum | order | family | genus | species | subspecies\t\thttp://www.worldfloraonline.org/taxon/wfo-0001096778\r\n\r\nThe issue here is that the cultivar is not a recognized name in the naming scheme used by wfo. After talking with some plant biologist, cultivars are not relevant when thinking from a species concept perspective. Therefore we are losing data due added complexity of the name. Essentially our choices are either we could limit the complexity of ALL names to just species level and retain this species or we could identify cases of  cultivars and remove them from the dataset or somehow notate them so they parse out (I believe there is an option for this in gn-parser), however, it seems more logical to apply an approach that circumvents all of these types of issues rather then patch work through each one we encounter as name complexity increases. \r\n\r\nThe overall problem is that the complexity in names warrants us to arbitrary choose the level a name should be parsed to, which can result in the loss of data.  **The goal should be to resolve names in our dataset to the lowest (taxonomic) level possible and label at which level this resolution happens** \r\n\r\nThe concept would go as follows: Run names through a parsing service and retrieve all of the variations of the name through parsing. This would result in the parsed names according to the scheme (includes subsp., var., and cultivars), the authorship, and finally 2 columns broken up with genus and specificEpithet. \r\n\r\nThe outputs of gbif parsing show...\r\ncanonicalNameWithMarker = Names including subsp., var., etc\r\ncanonicalName = Names without specifying subsp. var. etc (but still include names) ex: Zea mays subsp. mays -> Zea mays mays\r\ngenus = parsed out genus\r\nspecificEpithet = parsed out specificEpithet\r\nAuthorship = parsed out Authorship\r\n\r\nWe can then run this parsed name table through the following for-loop scheme. The goal would be to find the name at the lowest level of taxonomic resolution + authorship if possible. Failing that, we want to take successive steps back till resolution occurs and label at what level that name was capable of being resolved (if at all). \r\n\r\nboolean found = false\r\nif (authorship exists)\r\n    found = try canonicalNameWithMarker + authorship\r\nif (!found)\r\n    found = try canonicalNameWithMarker\r\nif (!found AND canonicalNameWithMarker != canonicalName)\r\n    found = try canonicalName\r\nif (!found)\r\n    found = try genusOrAbove + specificEpithet\r\n\r\nThis is still a rough framework, and I'm sure it has simplifications I am currently overlooking. However I think the overall goal is something that might improve the construction of datasets that include aggregated names, as currently choosing the one type of parsed name seems to cause issues in the dataset. Rather then losing data with being overly specific, It seems to make sense to me that finding resolution at just the species level would provide relevant information about the occurrence. \r\n\r\nLet me know your thoughts and especially criticisms! ","closed_by":null,"reactions":{"url":"https://api.github.com/repos/globalbioticinteractions/nomer/issues/128/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/globalbioticinteractions/nomer/issues/128/timeline","performed_via_github_app":null,"state_reason":null}